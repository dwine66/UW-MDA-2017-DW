source('~/GitHub/UW-MDA-2017-DW/Assignment 3 - DW.R', echo=TRUE)
car.stay.df.p <-  lapply(n, function(n) car.stay.df/n)
source('~/GitHub/UW-MDA-2017-DW/Assignment 3 - DW.R', echo=TRUE)
car.stay.df
source('~/GitHub/UW-MDA-2017-DW/Assignment 3 - DW.R', echo=TRUE)
source('~/GitHub/UW-MDA-2017-DW/Assignment 3 - DW.R', echo=TRUE)
source('~/GitHub/UW-MDA-2017-DW/Assignment 3 - DW.R', echo=TRUE)
source('~/GitHub/UW-MDA-2017-DW/Assignment 3 - DW.R', echo=TRUE)
source('~/GitHub/UW-MDA-2017-DW/Assignment 3 - DW.R', echo=TRUE)
source('~/GitHub/UW-MDA-2017-DW/Assignment 3 - DW.R', echo=TRUE)
source('~/GitHub/UW-MDA-2017-DW/Assignment 3 - DW.R', echo=TRUE)
car.stay.switch/n
car.stay.df/n
car.stay.df[1]
car.stay.df[1]/n[1]
car.stay.df[,]/n[,]
car.stay.df[]/n[]
for (i in 1:3){
car.stay.df.p <-  car.stay.df[,i]/n[.i]
}
for (i in 1:3){
car.stay.df.p <-  car.stay.df[,i]/n[,i]
}
car.stay.df[,]/n[]
car.stay.df[,1]/n[,1]
car.stay.df[,1]/n[i]
for (i in 1:3){
car.stay.df.p <-  car.stay.df[,i]/n[i]
}
car.stay.df.p
for (i in 1:3){
car.stay.df.p <-  car.stay.df[,i]/n[i]
car.switch.df.p <-  car.switch.df[,i]/n[i]
}
car.combined.df.p <- cbind(car.stay.df.p,car.switch.df.p)
bw <-.02
car.combined.df.p
car.stay.df.p
car.stay.df
for (i in 1:3){
car.stay.df.p[,i] <-  car.stay.df[,i]/n[i]
car.switch.df.p[,i] <-  car.switch.df[,i]/n[i]
}
car.combined.df.p
car.combined.df
car.stay.df/n
ddply(car.stay.df,.fun /n)
ddply(car.stay.df,.fun=function(n) car.stay.df/n .margins=1)
ddply(car.stay.df,.fun=function(n) /n .margins=1)
ddply(car.stay.df,.fun=function(n) x/n .margins=1)
ddply(car.stay.df,.fun=function(n) 'car.stay.df'/n .margins=1)
ddply(car.stay.df,.fun=function(n) {car.stay.df'/n} .margins=1)
)
ddply(car.stay.df,.fun=function(n) {car.stay.df/n})
ddply(car.stay.df,.fun=function(n) {car.stay.df/n},.margins=1)
lapply(car.stay.df,.fun=function(n) {car.stay.df/n})
lapply(car.stay.df,.FUN=function(n) {car.stay.df/n})
lapply(car.stay.df,FUN=function(n) {car.stay.df/n})
lapply(n,FUN=function(n) {car.stay.df/n})
car.switch.df.p <-  lapply(n, function(n) {car.switch.df/n})
lapply(car.stay.df,FUN=function(n) {car.stay.df/n})
car.switch.df.p <-  lapply(car.switch.df, function(n) {car.switch.df/n})
car.switch.df.p
car.switch.df.p <-  lapply(car.switch.df, margin=1, function(n) {car.switch.df/n})
car.switch.df.p[,1]=car.switch.df[,1]/n[1]
for (i in 1:3){
for(j in 1:m){
car.switch.df.p[j,i] <- car.switch.df[j,i]/n[i]
}
}
car.switch.df.p <- car.switch.df
for (i in 1:3){
for(j in 1:m){
car.switch.df.p[j,i] <- car.switch.df[j,i]/n[i]
}
}
car.stay.df.p <- car.stay.df
car.switch.df.p <- car.switch.df
for (i in 1:3){
for(j in 1:m){
car.stay.df.p[j,i] <- car.stay.df[j,i]/n[i]
car.switch.df.p[j,i] <- car.switch.df[j,i]/n[i]
}
}
car.combined.df.p <- cbind(car.stay.df.p,car.switch.df.p)
ggplot(car.combined.df.p,aes(x=low.st))+
geom_histogram(binwidth=bw,color='red', fill='NA',linetype='dotted',size=1)+
geom_histogram(binwidth=bw,aes(med.st),color='red', fill='NA',linetype='dashed',size=1)+
geom_histogram(binwidth=bw,aes(hi.st),color='red', fill='NA',linetype='solid',size=1)+
geom_histogram(binwidth=bw,aes(low.sw),color='blue', fill='NA',linetype='dotted',size=1)+
geom_histogram(binwidth=bw,aes(med.sw),color='blue', fill='NA',linetype='dashed',size=1)+
geom_histogram(binwidth=bw,aes(hi.sw),color='blue', fill='NA',linetype='solid',size=1) +
scale_x_continuous(breaks=seq(0,1,1/6), labels = c("0","1/6","1/3","1/2","2/3","5/6","1")) +
xlab("Probability of winning a car")+ylab("Frequency") +
ggtitle("Cars won by switching (blue) vs. staying (red)")
ggplot(car.combined.df.p,aes(x=low.st))+
geom_histogram(binwidth=bw,color='red', fill='NA',linetype='dotted',size=1)+
geom_histogram(binwidth=bw,aes(med.st),color='red', fill='NA',linetype='dashed',size=1)+
geom_histogram(binwidth=bw,aes(hi.st),color='red', fill='NA',linetype='solid',size=1)+
geom_histogram(binwidth=bw,aes(low.sw),color='blue', fill='NA',linetype='dotted',size=1)+
geom_histogram(binwidth=bw,aes(med.sw),color='blue', fill='NA',linetype='dashed',size=1)+
geom_histogram(binwidth=bw,aes(hi.sw),color='blue', fill='NA',linetype='solid',size=1) +
scale_x_continuous(breaks=seq(0,1,1/6), labels = c("0","1/6","1/3","1/2","2/3","5/6","1")) +
xlab("Probability of winning a car")+ylab("Frequency") +
ggtitle("Cars won by switching (blue) vs. staying (red)")
car.combined.df.p
source('~/GitHub/UW-MDA-2017-DW/Assignment 3 - DW.R', echo=TRUE)
source('~/GitHub/UW-MDA-2017-DW/Assignment 3 - DW.R', echo=TRUE)
install.packages('HistData')
install.packages('resample')
install.packages('simpleboot')
install.packages('learnbayes')
install.packages('LearnBayes')
require(ggplot2)
require(car)
require(plyr)
require(dplyr)
require(HistData)
require(resample)
require(simpleboot)
# UW Data Science 350
# Winter 2017
# Dave Wine 8430191
# Assignment #7: Regression
## Libraries
require ('MASS')
require ('repr')
require ('ggplot2')
require ('dplyr')
require ('HistData')
require ('glmnet')
require ('gridextra')
## Read in datafile
## Functions
# File read function
read.auto = function(file = 'Automobile price data _Raw_.csv'){
auto.data <- read.csv(file, header=TRUE, stringsAsFactors=FALSE)
numcols <- c('bore','stroke','horsepower','price','peak.rpm')
auto.data[, numcols]<-lapply(auto.data[,numcols], as.numeric)
factcols <- c('make','fuel.type','aspiration','num.of.doors','drive.wheels','engine.location','engine.type','num.of.cylinders','fuel.system','body.style')
auto.data[, factcols]<-lapply(auto.data[,factcols], as.factor)
auto.data[complete.cases(auto.data),]
}
####
# Main Code
####
# Read data in
auto.data <- read.auto()
# View dataset and summary statistics
str(auto.data)
summary(auto.data)
## Clean up dataset
## remove first two columns
auto.data <- auto.data[,-(1:2)]
## Transform price to log(price) based on previous work
auto.data$price <- log(auto.data$price)
##
##
## Check on factors
mod.mat <- model.matrix(price ~ ., data = auto.data)
mod.mat[1:10, ]
## Simple linear model
lm.price <- lm(price ~ ., data = auto.data)
summary(lm.price)
plot(lm.price)
### Stepwise Regression
lm.step <- stepAIC(lm.price, direction = 'both')
lm.step$anova # ANOVA of the result
summary(lm.step) # Summary of the best model
plot(lm.step)
setwd("~/GitHub/UW-MDA-2017-DW")
# UW Data Science 350
# Winter 2017
# Dave Wine 8430191
# Assignment #7: Regression
## Libraries
require ('MASS')
require ('repr')
require ('ggplot2')
require ('dplyr')
require ('HistData')
require ('glmnet')
require ('gridextra')
## Read in datafile
## Functions
# File read function
read.auto = function(file = 'Automobile price data _Raw_.csv'){
auto.data <- read.csv(file, header=TRUE, stringsAsFactors=FALSE)
numcols <- c('bore','stroke','horsepower','price','peak.rpm')
auto.data[, numcols]<-lapply(auto.data[,numcols], as.numeric)
factcols <- c('make','fuel.type','aspiration','num.of.doors','drive.wheels','engine.location','engine.type','num.of.cylinders','fuel.system','body.style')
auto.data[, factcols]<-lapply(auto.data[,factcols], as.factor)
auto.data[complete.cases(auto.data),]
}
####
# Main Code
####
# Read data in
auto.data <- read.auto()
# View dataset and summary statistics
str(auto.data)
summary(auto.data)
## Clean up dataset
## remove first two columns
auto.data <- auto.data[,-(1:2)]
## Transform price to log(price) based on previous work
auto.data$price <- log(auto.data$price)
##
##
## Check on factors
mod.mat <- model.matrix(price ~ ., data = auto.data)
mod.mat[1:10, ]
## Simple linear model
lm.price <- lm(price ~ ., data = auto.data)
summary(lm.price)
plot(lm.price)
### Stepwise Regression
lm.step <- stepAIC(lm.price, direction = 'both')
lm.step$anova # ANOVA of the result
summary(lm.step) # Summary of the best model
plot(lm.step)
M = as.matrix(auto.data)
View(M)
View(M)
head(M)
MTM = t(M) %*% M
MTM
View(M)
class(M)
View(auto.data)
View(auto.data)
mod.mat
mod.mat[1:10, ]
auto.mat <- model.matrix(price ~ ., data = auto.data)
auto.mat[1:10, ]
M = as.matrix(auto.mat)
head(M)
MTM = t(M) %*% M
MTM
cat('Compute and print the inverse singular value matrix')
d.trim = rep(0, 4)
d.trim[1:2] =1/ mSVD$d[1:2]
mD = diag(d.trim)
mD
cat('Compute and print the pseudo inverse')
mInv = mSVD$v %*% mD %*% t(mSVD$u)
mInv
cat('Compute and print the dimensions of the matrix MTMTM')
MTMTM = mInv %*% t(M)
dim(MTMTM)
MTM
cat('Compute and print the inverse singular value matrix')
d.trim = rep(0, 4)
d.trim[1:2] =1/ mSVD$d[1:2]
mD = diag(d.trim)
mD
cat('Compute and print the pseudo inverse')
mInv = mSVD$v %*% mD %*% t(mSVD$u)
mInv
mSVD <- SVD(M)
mSVD <- svd(M)
mSVD
cat('Compute and print the inverse singular value matrix')
d.trim = rep(0, 4)
d.trim[1:2] =1/ mSVD$d[1:2]
mD = diag(d.trim)
mD
cat('Compute and print the pseudo inverse')
mInv = mSVD$v %*% mD %*% t(mSVD$u)
mInv
cat('Compute and print the dimensions of the matrix MTMTM')
MTMTM = mInv %*% t(M)
dim(MTMTM)
d.trim = rep(0, 4)
d.trim[1:2] =1/ mSVD$d[1:2]
mD = diag(d.trim)
mD
length(mSVD$d)
d.trim = rep(0, mSVD$d)
d.trim[1:2] =1/ mSVD$d[1:2]
mD = diag(d.trim)
mD
d.trim = rep(0, length(mSVD$d))
d.trim
d.trim[1:2] =1/ mSVD$d[1:2]
mD = diag(d.trim)
mD
mSVD
mSVD$d
cat('Compute and print the inverse singular value matrix')
d.trim = rep(0, length(mSVD$d))
d.trim[1:10] =1/ mSVD$d[1:10]
mD = diag(d.trim)
mD
mInv = mSVD$v %*% mD %*% t(mSVD$u)
mInv
cat('Compute and print the dimensions of the matrix MTMTM')
MTMTM = mInv %*% t(M)
dim(MTMTM)
dim(M)
dim(mInv)
dim(t(M))
head(M)
MTM = t(M) %*% M
MTM
mInv = mSVD$v %*% mD %*% t(mSVD$u)
MTMTM = mInv %*% t(M)
MTM = t(M) %*% M
MTM
mSVD <- svd(MTM)
cat('Compute and print the inverse singular value matrix')
d.trim = rep(0, length(mSVD$d))
d.trim[1:10] =1/ mSVD$d[1:10]
mD = diag(d.trim)
mD
cat('Compute and print the pseudo inverse')
mInv = mSVD$v %*% mD %*% t(mSVD$u)
mInv
cat('Compute and print the dimensions of the matrix MTMTM')
MTMTM = mInv %*% t(M)
dim(MTMTM)
b <- MTMTM %*% auto.data$price
b
auto.data$score = M %*% b + mean(auto.data$price)
auto.data$resids = auto.data$score - auto.data$price
plot.svd.reg <- function(df, k = 4){
require(ggplot2)
require(gridExtra)
p1 <- ggplot(df) +
geom_point(aes(score, resids), size = 2) +
stat_smooth(aes(score, resids)) +
ggtitle('Residuals vs. fitted values')
p2 <- ggplot(df, aes(resids)) +
geom_histogram(aes(y = ..density..)) +
geom_density(color = 'red', fill = 'red', alpha = 0.2) +
ggtitle('Histogram of residuals')
qqnorm(df$resids)
grid.arrange(p1, p2, ncol = 2)
df$std.resids = sqrt((df$resids - mean(df$resids))^2)
p3 = ggplot(df) +
geom_point(aes(score, std.resids), size = 2) +
stat_smooth(aes(score, std.resids)) +
ggtitle('Standardized residuals vs. fitted values')
print(p3)
n = nrow(df)
Ybar = mean(df$childHeight)
SST <- sum((df$childHeight - Ybar)^2)
SSR <- sum(df$resids * df$resids)
SSE = SST - SSR
cat(paste('SSE =', as.character(SSE), '\n'))
cat(paste('SSR =', as.character(SSR), '\n'))
cat(paste('SST =', as.character(SSE + SSR), '\n'))
cat(paste('RMSE =', as.character(SSE/(n - 2)), '\n'))
adjR2  <- 1.0 - (SSR/SST) * ((n - 1)/(n - k - 1))
cat(paste('Adjusted R^2 =', as.character(adjR2)), '\n')
}
require(repr)
options(repr.pmales.extlot.width=8, repr.plot.height=4)
plot.svd.reg(auto.data)
cat('Compute and print the inverse singular value matrix')
thres <-5
d.trim = rep(0, length(mSVD$d))
d.trim[1:thres] =1/ mSVD$d[1:thres]
mD = diag(d.trim)
mD
cat('Compute and print the pseudo inverse')
mInv = mSVD$v %*% mD %*% t(mSVD$u)
mInv
cat('Compute and print the dimensions of the matrix MTMTM')
MTMTM = mInv %*% t(M)
dim(MTMTM)
b <- MTMTM %*% auto.data$price
auto.data$score = M %*% b + mean(auto.data$price)
auto.data$resids = auto.data$score - auto.data$price
require(repr)
options(repr.pmales.extlot.width=8, repr.plot.height=4)
plot.svd.reg(auto.data)
## Elastic Net Regression
cat('Compute and print the inverse singular value matrix')
lambda = 0.1
d.trim = 1/ (mSVD$d + lambda)
mD = diag(d.trim)
mD
cat('Compute and print the pseudo inverse')
mInv = mSVD$v %*% mD %*% t(mSVD$u)
mInv
MTMTM = mInv %*% t(M)
males.ext$score = M %*% b2 + mean(males.ext$childHeight)
males.ext$resids = males.ext$score - males.ext$childHeight
plot.svd.reg(males.ext)
cat('Compute and print the inverse singular value matrix')
thres <-10
d.trim = rep(0, length(mSVD$d))
d.trim[1:thres] =1/ mSVD$d[1:thres]
mD = diag(d.trim)
mD
cat('Compute and print the pseudo inverse')
mInv = mSVD$v %*% mD %*% t(mSVD$u)
mInv
cat('Compute and print the dimensions of the matrix MTMTM')
MTMTM = mInv %*% t(M)
dim(MTMTM)
b <- MTMTM %*% auto.data$price
auto.data$score = M %*% b + mean(auto.data$price)
auto.data$resids = auto.data$score - auto.data$price
require(repr)
options(repr.pmales.extlot.width=8, repr.plot.height=4)
plot.svd.reg(auto.data)
cat('Compute and print the inverse singular value matrix')
thres <-10
d.trim = rep(0, length(mSVD$d))
d.trim[1:thres] =1/ mSVD$d[1:thres]
mD = diag(d.trim)
mD
cat('Compute and print the pseudo inverse')
mInv = mSVD$v %*% mD %*% t(mSVD$u)
mInv
cat('Compute and print the dimensions of the matrix MTMTM')
MTMTM = mInv %*% t(M)
dim(MTMTM)
# Find model coefficients
b <- MTMTM %*% auto.data$price
# Compute Residuals
auto.data$score = M %*% b + mean(auto.data$price)
auto.data$resids = auto.data$score - auto.data$price
#Plot summary stats
require(repr)
options(repr.pmales.extlot.width=8, repr.plot.height=4)
plot.svd.reg(auto.data, thres)
cat('Compute and print the inverse singular value matrix')
thres <-3
d.trim = rep(0, length(mSVD$d))
d.trim[1:thres] =1/ mSVD$d[1:thres]
mD = diag(d.trim)
mD
cat('Compute and print the pseudo inverse')
mInv = mSVD$v %*% mD %*% t(mSVD$u)
mInv
cat('Compute and print the dimensions of the matrix MTMTM')
MTMTM = mInv %*% t(M)
dim(MTMTM)
# Find model coefficients
b <- MTMTM %*% auto.data$price
# Compute Residuals
auto.data$score = M %*% b + mean(auto.data$price)
auto.data$resids = auto.data$score - auto.data$price
#Plot summary stats
require(repr)
options(repr.pmales.extlot.width=8, repr.plot.height=4)
plot.svd.reg(auto.data, thres)
cat('Compute and print the inverse singular value matrix')
thres <-13
d.trim = rep(0, length(mSVD$d))
d.trim[1:thres] =1/ mSVD$d[1:thres]
mD = diag(d.trim)
mD
cat('Compute and print the pseudo inverse')
mInv = mSVD$v %*% mD %*% t(mSVD$u)
mInv
cat('Compute and print the dimensions of the matrix MTMTM')
MTMTM = mInv %*% t(M)
dim(MTMTM)
# Find model coefficients
b <- MTMTM %*% auto.data$price
# Compute Residuals
auto.data$score = M %*% b + mean(auto.data$price)
auto.data$resids = auto.data$score - auto.data$price
#Plot summary stats
require(repr)
options(repr.pmales.extlot.width=8, repr.plot.height=4)
plot.svd.reg(auto.data, thres)
cat('Compute and print the inverse singular value matrix')
lambda = 0.1
d.trim = 1/ (mSVD$d + lambda)
mD = diag(d.trim)
mD
cat('Compute and print the pseudo inverse')
mInv = mSVD$v %*% mD %*% t(mSVD$u)
mInv
MTMTM = mInv %*% t(M)
b2 <- MTMTM %*% auto.data$price
auto.data$score = M %*% b2 + mean(auto.data$price)
auto.data$resids = auto.data$score - auto.data$price
plot.svd.reg(auto.data,thres)
require(glmnet)
b = as.matrix(auto.data$price)
mod.ridge = glmnet(M, b, family = 'gaussian', nlambda = 20, alpha = 0.0)
plot(mod.ridge, xvar = 'lambda', label = TRUE)
plot(mod.ridge, xvar = 'dev', label = TRUE)
mod.lasso = glmnet(M, b, family = 'gaussian', nlambda = 20, alpha = 1.0)
plot(mod.lasso, xvar = 'lambda', label = TRUE)
plot(mod.lasso, xvar = 'dev', label = TRUE)
mod.ridge.lasso = glmnet(M, b, family = 'gaussian', nlambda = 20, alpha = 0.5)
plot(mod.ridge.lasso, xvar = 'lambda', label = TRUE)
plot(mod.ridge.lasso, xvar = 'dev', label = TRUE)
auto.data$score = predict(mod.ridge.lasso, newx = M)[, 15]
auto.data$resids = auto.data$score - auto.data$price
plot.svd.reg(auto.data)
require(glmnet)
b = as.matrix(auto.data$price)
mod.ridge = glmnet(M, b, family = 'gaussian', nlambda = 20, alpha = 0.0)
plot(mod.ridge, xvar = 'lambda', label = TRUE)
plot(mod.ridge, xvar = 'dev', label = TRUE)
mod.lasso = glmnet(M, b, family = 'gaussian', nlambda = 20, alpha = 1.0)
plot(mod.lasso, xvar = 'lambda', label = TRUE)
plot(mod.lasso, xvar = 'dev', label = TRUE)
mod.ridge.lasso = glmnet(M, b, family = 'gaussian', nlambda = 20, alpha = 0.5)
plot(mod.ridge.lasso, xvar = 'lambda', label = TRUE)
plot(mod.ridge.lasso, xvar = 'dev', label = TRUE)
auto.data$score = predict(mod.ridge.lasso, newx = M)[, 15]
auto.data$resids = auto.data$score - auto.data$price
plot.svd.reg(auto.data)
