PVdata<-read.table("Aphid_B_Working.csv",header=true,sep=",",quote="'"")
PVdata<-read.table("Aphid_B_Working.csv",header=true,sep=",",quote="\"")
PVdata<-read.table("Aphid_B_Working.csv",header=true,sep=",",quote="\"")
PVdata<-read.table("Aphid_B_Working.csv",header=TRUE,sep=",",quote="\"")
PVdata
PVdata.header
PVdata.head
PVdata[head()]
PVdata[head]
PVdata[head()]
PVdata[head(1)]
PVdata[1]
PVdata[2]
PVdata[,1]
PVdata[1,]
x<-PVdata[X1.yr]
type(PVdata)
View(PVdata)
x<-PVdata[,3]
x
dnorm(x)
dnorm(0)
dnorm(1)
dnorm(-1)
dnorm(-3)
qnorm(-3)
qnorm(0)
qnorm(1)
qnorm(.1)
rnorm(4)
install.packages("ggplot2")
install.packages(c('repr', 'IRdisplay', 'evaluate', 'crayon', 'pbdZMQ', 'devtools', 'uuid', 'digest'))
devtools::install_github('IRkernel/IRkernel')
IRkernel::installspec(user = FALSE)
ggplot(bldg.data, aes(Surface.Area, Cooling.Load)) + geom_point(aes(color = factor(Overall.Height))) +
xlab('Surface Area') + ylab('Heating Load') +
ggtitle('Relationship between Cooling Load and Surface Area, \n with Overall Height Shown')
install.packages('ellipse')
setwd("~/GitHub/UW-MDA-2017-DW")
#UW Data Science - Winter 2017
#Assignment #1
#Dave Wine 8430191
# Import packages
require(ggplot2)
require(car)
require(gridExtra)
# File read function
read.bldg = function(file = 'EnergyEfficiencyData.csv'){
bldg.data <- read.csv(file, header=TRUE, stringsAsFactors=FALSE)
factcols <- c('Orientation','Glazing.Area.Distribution')
bldg.data[, factcols]<-lapply(bldg.data[,factcols], as.numeric)
bldg.data[complete.cases(bldg.data),]
}
# 2D Scatterplot function
#This works OK but I haven't figured out how to pass or infer labels yet....
plots.2DS <- function(x,y,c){
ggplot(bldg.data, aes(x, y)) + geom_point(aes(color = factor(c)))
#+
#xlab(x) + ylab(y) +
#ggtitle('Relationship between'+ x +' and ' + y +' \n with '+c+' Shown')
}
# normalization function
norm <- function(x){
return((x-min(x))/(max(x)-min(x)))
#  return (min(x))
}
# denormalization function
denorm <- function(x){
#TBD
}
# Read data in
bldg.data <- read.bldg()
# View dataset and summary statistics
str(bldg.data)
summary(bldg.data)
# denormalization function
denorm <- function(x){
#TBD
}
# Read data in
bldg.data <- read.bldg()
# View dataset and summary statistics
str(bldg.data)
summary(bldg.data)
# Create Factors from appropriate variables
factOrient <- cut(bldg.data$Orientation,breaks=4,labels=1:4)
#factOrient <- lapply(factOrient, as.character)
factDist <- cut(bldg.data$Glazing.Area.Distribution,breaks=6,labels=1:6)
#factDist <- lapply(factDist, as.character)
factHeight <- cut(bldg.data$Overall.Height,breaks=2,labels=1:2)
# Some subsets that seemed useful:
Tall<-subset(bldg.data,Overall.Height==7)
Short<-subset(bldg.data,Overall.Height==3.5)
# Test normalization function
SA.n <- norm(bldg.data$Surface.Area)
WA.n <- norm(bldg.data$Wall.Area)
RA.n <- norm(bldg.data$Roof.Area)
HL.n <- norm(bldg.data$Heating.Load)
CL.n <- norm(bldg.data$Cooling.Load)
#OR try lapply for normalization
bldg.data.n <- lapply(bldg.data,norm)
class(bldg.data.n)
require(plyr)
bldg.data.ndf <- ddply(bldg.data,norm)
bldg.data.ndf <- ddply(.bldg.data,.norm)
bldg.data.ndf <- ddply(.data=bldg.data,.fun=norm)
# normalization function
norm <- function(x){
return((x-min(x))/(max(x)-min(x)))
#  return (min(x))
}
bldg.data.ndf <- ddply(.data=bldg.data,.fun=norm)
bldg.data.n <-ddply(.data=bldg.data,.variables=bldg.data$colnames,.fun=norm)
bldg.data.n
